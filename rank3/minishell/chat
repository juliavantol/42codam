void	divide_command_in_redirections(t_cmd *node, char *command, int i)
{
	char		**cmd;
	char		*temp;

	cmd = ft_split(command, ' ');
	while (cmd[i])
	{
		if (ft_strcmp(cmd[i], ">") && cmd[i + 1])
		{
			node->output_redirection = true;
			add_node(&node->outputs, cmd[i + 1], TRUNCATE);
			i++;
		}
		else if (ft_strcmp(cmd[i], ">>") && cmd[i + 1])
		{
			node->output_redirection = true;
			add_node(&node->outputs, cmd[i + 1], APPEND);
			i++;
		}
		else if (ft_strcmp(cmd[i], "<") && cmd[i + 1])
		{
			node->input_redirection = true;
			add_node(&node->inputs, cmd[i + 1], READ);
			i++;
		}
		else if (ft_strcmp(cmd[i], "<<") && cmd[i + 1])
		{
			node->input_redirection = true;
			add_node(&node->inputs, cmd[i + 1], HEREDOC);
			i++;
		}
		else
		{
			temp = ft_strdup(node->command_name);
			free(node->command_name);
			node->command_name = join_three_strs(temp, " ", cmd[i]);
			free(temp);
		}
		i++;
	}
	empty_array(cmd);
}

void	make_command_structs(t_exe *executor, char **command_line_split)
{
	t_cmd	*node;
	int		i;

	i = 0;
	while (command_line_split[i])
	{
		node = ft_malloc(sizeof(t_cmd));
		node->command_name = ft_strdup("");
		node->outputs = NULL;
		node->inputs = NULL;
		node->output_redirection = false;
		node->input_redirection = false;
		divide_command_in_redirections(node, command_line_split[i], 0);
		executor->commands[i] = node;
		i++;
	}
	executor->commands[i] = NULL;
}

void	temp_parser(t_exe *executor, char *input)
{
	char	**command_line_split;
	int		i;

	i = 0;
	command_line_split = ft_split(input, '|');
	while (command_line_split[i] != NULL)
		i++;
	executor->command_count = i;
	executor->current_directory = NULL;
	executor->commands = ft_malloc(sizeof(t_cmd *) * (i + 1));
	executor->old_fds[0] = dup(READ);
	executor->old_fds[1] = dup(WRITE);
	executor->exit_code = 0;
	make_command_structs(executor, command_line_split);
	empty_array(command_line_split);
	start_executor(executor, 0);
}

t_filenames	*last_node(t_filenames *filename)
{
	t_filenames	*temp;

	temp = filename;
	if (filename != NULL)
	{
		while (temp->next != NULL)
			temp = temp->next;
	}
	return (temp);
}

t_filenames	*new_node(char *name, int mode)
{
	t_filenames	*node;

	node = malloc(sizeof(t_filenames));
	if (node == NULL)
		return (NULL);
	if (name == NULL)
		node->filename = NULL;
	else
		node->filename = ft_strdup(name);
	node->mode = mode;
	node->next = NULL;
	return (node);
}

void	add_node(t_filenames **filenames, char *name, int mode)
{
	t_filenames	*last;
	t_filenames	*new;

	new = new_node(name, mode);
	if (*filenames != NULL && new != NULL)
	{
		last = last_node(*filenames);
		last->next = new;
	}
	else
		*filenames = new;
}

void	start_executor(t_exe *executor, int i)
{
	while (i < executor->command_count)
	{
		check_builtin(executor, executor->commands[i]);
		// if (!check_builtin(executor, executor->commands[i]))
		// {
		// 	if (i < executor->command_count - 1)
		// 		handle_command(executor, executor->commands[i]);
		// 	else
		// 		last_command(executor, executor->commands[i]);
		// }
		i++;
	}
	free_cmds(executor);
}

bool	check_builtin(t_exe *executor, t_cmd *command)
{
	char	**name;

	name = ft_split(command->command_name, ' ');
	if (ft_strcmp(name[0], "pwd") == true)
		printf("%s\n", executor->current_directory);
	else if (ft_strcmp(name[0], "echo") == true)
		exit(1);
	else if (ft_strcmp(name[0], "env") == true)
		print_env(executor);
	else if (ft_strcmp(name[0], "cd") == true)
		cd(executor, name[1]);
	else if (ft_strcmp(name[0], "export") == true)
		export(executor, name[1], name[2]);
	else if (ft_strcmp(name[0], "unset") == true)
		unset(executor, name[1]);
	else if (ft_strcmp(name[0], "exit") == true)
	{
		empty_array(name);
		exit_shell(executor);
	}
	else
	{
		empty_array(name);
		return (false);
	}
	empty_array(name);
	return (true);
}

void	empty_array(char **arr)
{
	int	i;

	i = 0;
	if (arr)
	{
		while (arr[i])
			free(arr[i++]);
		free(arr);
		arr = NULL;
	}
}

void	free_filenames(t_filenames *list)
{
	t_filenames	*temp;

	while (list != NULL)
	{
		temp = list;
		list = list->next;
		free(temp->filename);
		free(temp);
	}
}

void	free_cmds(t_exe *executor)
{
	int	i;

	i = 0;
	while (executor->commands[i])
	{
		if (executor->commands[i]->command_name != NULL)
			free(executor->commands[i]->command_name);
		if (executor->commands[i]->outputs != NULL)
			free_filenames(executor->commands[i]->outputs);
		if (executor->commands[i]->inputs != NULL)
			free_filenames(executor->commands[i]->inputs);
		free(executor->commands[i]);
		i++;
	}
}

void	free_envp(t_envp *list)
{
	t_envp	*temp;

	while (list != NULL)
	{
		temp = list;
		list = list->next;
		free(temp->key);
		free(temp->value);
		free(temp);
	}
}

void	empty_executor(t_exe *executor)
{
	int	i;

	// // free(executor->current_directory);
	i = 0;
	if (executor->envp)
	{
		while (executor->envp[i])
			free(executor->envp[i++]);
		free(executor->envp);
		executor->envp = NULL;
	}
	i = 0;
	if (executor->paths)
	{
		while (executor->paths[i])
		{
			free(executor->paths[i]);
			i++;
		}
		free(executor->paths);
		executor->paths = NULL;
	}
}