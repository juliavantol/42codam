void	temp_parser(t_exe *executor, char *input)
{
	char	**command_line_split;
	int		i;

	i = 0;
	command_line_split = ft_split(input, '|');
	while (command_line_split[i] != NULL)
		i++;
	executor->command_count = i;
	executor->current_directory = get_pwd();
	executor->commands = ft_malloc(sizeof(t_cmd *) * (i + 1));
	executor->old_fds[0] = dup(READ);
	executor->exit_code = 0;
	executor->old_fds[1] = dup(WRITE);
	make_command_structs(executor, command_line_split);
	empty_array(command_line_split);
	start_executor(executor, 0);
}

int	main(int argc, char **argv, char **envp)
{
	char	*input;
	t_exe	executor;

	if (!proper_start(argc, argv))
		return (EXIT_FAILURE);
	// init_signal_handler();
	init_executor(&executor, envp);
	while (1)
	{
		reset_fd(&executor);
		input = init_prompt("minishell$ ");
		if (!input)
			return (EXIT_SUCCESS);
		temp_parser(&executor, input);
		free(input);
	}
	empty_executor(&executor);
}

void	empty_array(char **arr)
{
	int	i;

	i = 0;
	if (arr)
	{
		while (arr[i])
			free(arr[i++]);
		free(arr);
		arr = NULL;
	}
}

void	free_filenames(t_filenames *list)
{
	t_filenames	*temp;

	while (list != NULL)
	{
		temp = list;
		list = list->next;
		free(temp->filename);
		free(temp);
	}
}

void	free_cmds(t_exe *executor)
{
	int	i;

	i = 0;
	while (executor->commands[i])
	{
		if (executor->commands[i]->command_name != NULL)
			free(executor->commands[i]->command_name);
		if (executor->commands[i]->outputs != NULL)
			free_filenames(executor->commands[i]->outputs);
		if (executor->commands[i]->inputs != NULL)
			free_filenames(executor->commands[i]->inputs);
		free(executor->commands[i]);
		i++;
	}
}

void	free_envp(t_envp *list)
{
	t_envp	*temp;

	while (list != NULL)
	{
		temp = list;
		list = list->next;
		free(temp->key);
		free(temp->value);
		free(temp);
	}
}

void	empty_executor(t_exe *executor)
{
	int	i;

	return ;
	free(executor->current_directory);
	free_cmds(executor);
	free(executor->commands);
	free_envp(executor->envp_list);
	i = 0;
	if (executor->envp)
	{
		while (executor->envp[i])
			free(executor->envp[i++]);
		free(executor->envp);
		executor->envp = NULL;
	}
	i = 0;
	if (executor->paths)
	{
		while (executor->paths[i])
			free(executor->paths[i++]);
		free(executor->paths);
		executor->paths = NULL;
	}
}

bool	check_builtin(t_exe *executor, t_cmd *command)
{
	char	**name;

	name = ft_split(command->command_name, ' ');
	if (ft_strcmp(name[0], "pwd") == true)
		printf("%s\n", executor->current_directory);
	else if (ft_strcmp(name[0], "echo") == true)
		exit(1);
	else if (ft_strcmp(name[0], "env") == true)
		print_env(executor);
	else if (ft_strcmp(name[0], "cd") == true)
		cd(executor, name[1]);
	else if (ft_strcmp(name[0], "export") == true)
		export(executor, name[1], name[2]);
	else if (ft_strcmp(name[0], "unset") == true)
		unset(executor, name[1]);
	else if (ft_strcmp(name[0], "exit") == true)
	{
		empty_array(name);
		exit_shell(executor);
	}
	else
	{
		empty_array(name);
		return (false);
	}
	empty_array(name);
	return (true);
}

char	*get_pwd(void)
{
	char	*path;

	path = ft_malloc(PATH_MAX + 1);
	getcwd(path, PATH_MAX + 1);
	return (path);
}

void	run_command(t_exe *executor, t_cmd *command)
{
	char	*path;
	char	**cmd;

	cmd = ft_split(command->command_name, ' ');
	path = get_cmd_path(executor, cmd[0], 0);
	if (!path)
		error_exit("Command not found");
	if (execve(path, cmd, convert_envp(executor)) == -1)
		error_exit("Execve error");
}

void	last_command(t_exe *executor, t_cmd *command)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
		error_exit("Error with fork");
	if (pid == 0)
	{
		redirect_input(command);
		redirect_output(command);
		run_command(executor, command);
		exit(EXIT_SUCCESS);
	}
	else
	{
		dup2(executor->old_fds[WRITE], WRITE);
		waitpid(pid, &executor->status, 0);
		if (WIFEXITED(executor->status))
			executor->exit_code = WEXITSTATUS(executor->status);
	}
}

void	handle_command(t_exe *executor, t_cmd *command)
{
	pid_t	pid;

	if (pipe(executor->fds) < 0)
		error_exit("Error with opening the pipe");
	pid = fork();
	if (pid < 0)
		error_exit("Error with fork");
	if (pid == 0)
	{
		redirect_input(command);
		redirect_output(command);
		close(executor->fds[READ]);
		if (!command->output_redirection)
			dup2(executor->fds[WRITE], WRITE);
		run_command(executor, command);
		exit(EXIT_SUCCESS);
	}
	else
	{
		waitpid(pid, &executor->status, 0);
		if (WIFEXITED(executor->status))
			executor->exit_code = WEXITSTATUS(executor->status);
		close(executor->fds[WRITE]);
		dup2(executor->fds[READ], READ);
	}
}

void	start_executor(t_exe *executor, int i)
{
	while (i < executor->command_count)
	{
		if (!check_builtin(executor, executor->commands[i]))
		{
			if (i < executor->command_count - 1)
				handle_command(executor, executor->commands[i]);
			else
				last_command(executor, executor->commands[i]);
		}
		i++;
	}
}